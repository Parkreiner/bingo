// Package cardregistry defines a centralized registry for generating and using
// bingo cards, to help ensure that cards remain unique among players, and that
// a player cannot receive multiple cards that are too similar to each other.
package cardregistry

import (
	"errors"
	"fmt"
	"slices"
	"sync"
	"time"

	"github.com/Parkreiner/bingo"
	"github.com/google/uuid"
)

// The number of cells that two cards are allowed to have in common to still
// be called unique from a fun, gameplay standpoint. A unique cell, in this
// case, refers to not just the numeric value of a cell, but also the
// position.
//
// The number is 2/3 of the total cells of a bingo card (25), excluding the
// free space.
const uniquenessThreshold = 16

// Indicates the maximum number of attempts that the CardRegistry is able to
// make at creating a single unique bingo card in one sitting
const maxGenAttempts = 256

// The minimum surplus allowed by a CardRegistry. Should generally be some
// multiple of the max number of cards a player can have, so that multiple
// players can get started relatively quickly
const minEntrySurplus = 100 * bingo.MaxCards
const maxEntrySurplus = 200 * bingo.MaxCards

// registryBingoCard represents a single bingo card generated by a CardRegistry.
// These cards should be treated as the main source of truth for bingo cards for
// any system that uses CardRegistry, with any bingo cards emitted being treated
// as "borrowed snapshots"
type registryBingoCard struct {
	// cells defines a 2D grid of bingo cells. Should be treated as 100%
	// immutable
	cells [][]bingo.Ball
	// Should be treated as 100% immutable
	id uuid.UUID
	// Used to make sure that the same player can't be given the same card
	// multiple times, even after they return it
	prevPlayerIDs []uuid.UUID
	// Indicates whether the card has been checked out and is in use by an
	// external system
	checkedOut bool
}

// status represents the status of a CardRegistry
type status string

const (
	// statusIdle indicates that the CardRegistry is ready to start
	statusIdle status = "idle"
	// statusRunning indicates that the CardRegistry has started and is
	// ready to use
	statusRunning status = "running"
	// statusTerminated indicates that the CardRegistry has been killed, and
	// cannot be used any longer. A user will need to make a new CardRegistry
	// instance
	statusTerminated status = "terminated"
)

// Registry defines an instance of a centralized bingo card registry. It
// should not be copied once initialized. To start using a registry, call the
// Start method. Once a registry has been terminated, it cannot be used to
// generate any additional cards, and a new registry will need to be created
// from scratch
type Registry struct {
	status            status
	statusMtx         *sync.RWMutex
	registeredEntries []*registryBingoCard
	entriesMtx        *sync.Mutex
	generator         *cellsGenerator
	doneChan          chan struct{}
	cardReturnChan    chan uuid.UUID
	surplusTicker     *time.Ticker
}

// NewCardRegistry produces a new instance of a CardRegistry. It is not ready to
// use until you call the .Start method on it.
func NewCardRegistry(rngSeed int64) *Registry {
	return &Registry{
		status:            statusIdle,
		registeredEntries: nil,
		entriesMtx:        &sync.Mutex{},
		statusMtx:         &sync.RWMutex{},
		generator:         newCellsGenerator(rngSeed),
		doneChan:          make(chan struct{}),
		cardReturnChan:    make(chan uuid.UUID, 1),
		surplusTicker:     nil,
	}
}

func (cr *Registry) getStatus() status {
	cr.statusMtx.RLock()
	defer cr.statusMtx.Unlock()
	return cr.status
}

// equalizeEntrySurplus ensures that the registry does not have too many or too
// few extra bingo cards. This helps because of the random nature of the bingo
// card generation logic. (Needing to generate multiple cards with a threshold
// for uniqueness can take some time to run.)
// This method is meant to be a background operation, so we need to be very
// mindful of how long we keep things locked for each operation.
func (cr *Registry) equalizeEntrySurplus() {
	// Add any needed surplus
	availableCards := 0
	for availableCards < minEntrySurplus {
		availableCards = 0

		cr.entriesMtx.Lock()
		for _, entry := range cr.registeredEntries {
			if !entry.checkedOut {
				availableCards++
			}
		}
		cr.entriesMtx.Unlock()

		if availableCards < minEntrySurplus {
			_, _ = cr.generateUniqueEntry()
		}
	}

	// Prune any extra surplus - there is a small risk that the value of
	// availableCards could get inaccurate by the time we do this if branch, but
	// that	shouldn't be a huge deal
	if availableCards < maxEntrySurplus {
		return
	}
	cr.entriesMtx.Lock()
	defer cr.entriesMtx.Unlock()
	slices.SortFunc(cr.registeredEntries, func(e1 *registryBingoCard, e2 *registryBingoCard) int {
		if e1.checkedOut && !e2.checkedOut {
			return -1
		}
		if e2.checkedOut && !e1.checkedOut {
			return 1
		}
		return 0
	})

	var endIndex int
	for endIndex = len(cr.registeredEntries) - 1; endIndex >= 0; endIndex-- {
		entry := cr.registeredEntries[endIndex]
		if entry.checkedOut {
			break
		}
	}
	cr.registeredEntries = cr.registeredEntries[0 : endIndex+1]
}

// flushReturn marks a bingo card as ready to be reused by another player.
// Reusing existing cards helps minimize the costs of generating new cards on
// a regular basis.
func (cr *Registry) flushReturn(cardID uuid.UUID) {
	cr.entriesMtx.Lock()
	defer cr.entriesMtx.Unlock()

	for _, entry := range cr.registeredEntries {
		if cardID == entry.id {
			entry.checkedOut = false
			break
		}
	}
}

// Start attempts to start a CardRegistry, erroring only if the registry was
// already terminated. The method returns a cleanup function for terminating the
// registry. Calling the cleanup function multiple times is fine â€“ all calls
// after the first become no-ops
func (cr *Registry) Start() (func(), error) {
	status := cr.getStatus()
	if status == statusTerminated {
		return nil, errors.New("trying to start terminated CardGen")
	}

	cleanup := func() {
		select {
		case cr.doneChan <- struct{}{}:
		default:
		}
	}
	if status == statusRunning {
		return cleanup, nil
	}

	cr.statusMtx.Lock()
	defer cr.statusMtx.Unlock()
	cr.status = statusRunning
	// Pre-populate the registry to get ready for new players
	cr.equalizeEntrySurplus()
	cr.surplusTicker = time.NewTicker(5 * time.Second)

	go func() {
		defer func() {
			cr.statusMtx.Lock()
			defer cr.statusMtx.Unlock()
			cr.status = statusTerminated
			close(cr.cardReturnChan)
			cr.surplusTicker.Stop()
		}()

	loop:
		for {
			select {
			case <-cr.doneChan:
				break loop
			case returnedCardID := <-cr.cardReturnChan:
				cr.flushReturn(returnedCardID)
			case <-cr.surplusTicker.C:
				cr.equalizeEntrySurplus()
			}
		}
	}()

	return cleanup, nil
}

// generateUniqueEntry creates a new entry for the registry, making sure that it
// follows some requirements for being unique relative to all other registered
// cards.
func (cr *Registry) generateUniqueEntry() (*registryBingoCard, error) {
	// Looked into trying to split up the unlocking logic, since there's a
	// chance that the uniqueness generation could take a while. That felt way
	// too risky, since even if we lock in two steps (once for grabbing
	// comparison snapshots, and again for appending the entry), there would be
	// a period of time when another consumer could generate a new card that
	// violates the uniqueness criteria of the card we just generated. Better to
	// stay locked the entire time to make race conditions impossible
	cr.entriesMtx.Lock()
	defer cr.entriesMtx.Unlock()

	var newCells [][]bingo.Ball
	var attempts int
	for attempts = 1; attempts <= maxGenAttempts; attempts++ {
		newCells = cr.generator.generateCells()
		cellConflicts := 0

		for _, entry := range cr.registeredEntries {
			for i, row := range entry.cells {
				for j, cell := range row {
					// Skip over the free space
					if cell == bingo.FreeSpace {
						continue
					}

					newCell := newCells[i][j]
					if cell == newCell {
						cellConflicts++
					}
				}
			}
		}

		if cellConflicts <= uniquenessThreshold {
			break
		}
	}

	if attempts > maxGenAttempts {
		return nil, errors.New("ran out of attempts to generate new bingo card")
	}

	newEntry := &registryBingoCard{
		cells:         newCells,
		id:            uuid.New(),
		prevPlayerIDs: nil,
		checkedOut:    false,
	}
	cr.registeredEntries = append(cr.registeredEntries, newEntry)
	return newEntry, nil
}

// checkOutRecycledEntry tries to check out an existing bingo card that is not
// currently being used. If one could be found, the card is updated to an active
// state and the player ID's is registered with it. Returns nil if none could be
// found.
func (cr *Registry) checkOutRecycledEntry(playerID uuid.UUID) *registryBingoCard {
	cr.entriesMtx.Lock()
	defer cr.entriesMtx.Unlock()

	for _, entry := range cr.registeredEntries {
		foundReusable := !entry.checkedOut && !slices.Contains(entry.prevPlayerIDs, playerID)
		if foundReusable {
			entry.checkedOut = true
			entry.prevPlayerIDs = append(entry.prevPlayerIDs, playerID)
			return entry
		}
	}
	return nil
}

// CheckOutCard lets a player check out a new, stateful bingo card. The bingo
// card is guaranteed to have a minimum threshold for uniqueness compared to all
// bingo cards that the player has used already. Errors if the method is called
// while CardRegistry is not running, or if the Registry cannot find a card for
// the player.
func (cr *Registry) CheckOutCard(playerID uuid.UUID) (*bingo.Card, error) {
	status := cr.getStatus()
	if status == statusIdle {
		return nil, errors.New("must Start CardGen before calling other methods")
	}
	if status == statusTerminated {
		return nil, errors.New("tried generating card for terminated CardGen")
	}

	cr.entriesMtx.Lock()
	playerCards := 0
	for _, entry := range cr.registeredEntries {
		if slices.Contains(entry.prevPlayerIDs, playerID) {
			playerCards++
		}
	}
	cr.entriesMtx.Unlock()

	if playerCards >= bingo.MaxCards {
		return nil, errors.New("player cannot check out any more cards")
	}

	var activeEntry *registryBingoCard
	reusable := cr.checkOutRecycledEntry(playerID)
	if reusable != nil {
		activeEntry = reusable
	} else {
		activeEntry, err := cr.generateUniqueEntry()
		if err != nil {
			return nil, fmt.Errorf("CheckOutCard: %v", err)
		}

		cr.entriesMtx.Lock()
		activeEntry.checkedOut = true
		activeEntry.prevPlayerIDs = append(activeEntry.prevPlayerIDs, playerID)
		cr.entriesMtx.Unlock()
	}

	var statefulCells [][]*bingo.Cell
	for _, row := range activeEntry.cells {
		var statefulRow []*bingo.Cell
		for _, cell := range row {
			statefulRow = append(statefulRow, &bingo.Cell{
				Daubed: false,
				Number: cell,
			})
		}
		statefulCells = append(statefulCells, statefulRow)
	}

	return &bingo.Card{
		PlayerID: playerID,
		ID:       activeEntry.id,
		Cells:    statefulCells,
	}, nil
}

// ReturnCard lets a player return a card that they no longer wish to use. Once
// returned, a card is allowed to be given out to other players, but a player
// will never receive a card they have already returned if they call CheckOut in
// the future. Errors if the method is called while CardRegistry is not running.
func (cr *Registry) ReturnCard(cardID uuid.UUID) error {
	status := cr.getStatus()
	if status == statusIdle {
		return errors.New("must Start CardGen before returning card")
	}
	if status == statusTerminated {
		return errors.New("tried returning card to terminated CardGen")
	}

	cr.cardReturnChan <- cardID
	return nil
}
